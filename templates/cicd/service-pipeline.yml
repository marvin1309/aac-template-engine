# This is a reusable GitLab CI/CD pipeline for service repositories.
# It automates the generation, validation, and commit of deployment configurations.
#
# How to use:
# In your service's .gitlab-ci.yml, include this file:
#
# include:
#   - project: 'aac-application-definitions/aac-template-engine'
#     ref: main
#     file: '/templates/cicd/service-pipeline.yml'
#
# Required CI/CD variables in the service project's settings:
# - GIT_PUSH_TOKEN: A GitLab Project Access Token with the 'write_repository' scope.
#                   This is required for the pipeline to commit generated files back to the repo.
default:
  # Ensure all jobs run on a runner with the 'docker' tag.
  # This is important if you have specific runners (e.g., Windows or Linux with Docker).
  tags:
    - docker

workflow:
  rules: # Allow pipelines to run for branch pushes and tag pushes
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

stages:
  - generate
  - validate
  - commit
  - test
  - release

.generate-job:
  stage: generate
  # Use a standard Python image and install dependencies on the fly.
  image: python:3.9-slim
  before_script:
    # The python:slim image is Debian-based and doesn't include git.
    - apt-get update && apt-get install -y --no-install-recommends git
    # Install Python dependencies for the generation script
    - pip install PyYAML Jinja2
    # Clone the template engine repository to get access to the generation script and templates.
    # This requires a token with 'read_repository' scope, defined as a CI/CD variable GIT_PUSH_TOKEN.
    - git clone "https://gitlab-ci-token:${CI_GITLAB_TOKEN_GLOBAL_FESER}@${CI_SERVER_HOST}/aac-application-definitions/aac-template-engine.git"
    # The script expects the 'templates' directory to be in the current working directory.
    - cp -r aac-template-engine/templates .
  script:
    - echo "Generating '$DEPLOYMENT_TYPE' deployment..."
    # Run the script from its location in the cloned repo. It will read service.yml from the CWD.
    - python aac-template-engine/scripts/generate_manifest.py --ssot-file service.yml --deployment-type $DEPLOYMENT_TYPE
  artifacts:
    paths:
      - deployments/
    expire_in: 1 hour
generate-docker-compose:
  extends: .generate-job
  variables:
    DEPLOYMENT_TYPE: docker_compose

  rules:
    - if: '$CI_COMMIT_BRANCH'

generate-kubernetes:
  extends: .generate-job
  variables:
    DEPLOYMENT_TYPE: kubernetes
  rules:
    - if: '$CI_COMMIT_BRANCH'

validate-docker-compose:
  stage: validate
  image: docker:latest
  services:
    - docker:dind
  needs:
    - generate-docker-compose
  script:
    - |
      if [ -f "deployments/docker_compose/docker-compose.yml" ]; then
        echo "Validating generated docker-compose.yml syntax..."
        apk add --no-cache docker-compose
        docker-compose -f deployments/docker_compose/docker-compose.yml config
      else
        echo "No docker-compose.yml found to validate."
        exit 1
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH'
    
#validate-kubernetes:
#  stage: validate
#  image:
#    name: bitnami/kubectl:latest
#    entrypoint: [""]
#  needs:
#    - generate-kubernetes
#  script:
#    - |
#      if [ -f "deployments/kubernetes/kubernetes.yml" ]; then
#        echo "Validating generated kubernetes.yml syntax..."
#        kubectl apply --dry-run=client -f deployments/kubernetes/kubernetes.yml
#      else
#        echo "No kubernetes.yml found to validate."
#        exit 1
#      fi
#  rules:
#    - if: '$CI_COMMIT_BRANCH'

commit-generated-files:
  stage: commit
  image: alpine:latest
  needs:
    - validate-docker-compose
#    - validate-kubernetes
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci-bot@${CI_SERVER_HOST}"
    - git config --global user.name "GitLab CI Bot"
    - git remote set-url origin "https://gitlab-ci-token:${CI_GITLAB_TOKEN_GLOBAL_FESER}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - git fetch
    - git checkout $CI_COMMIT_BRANCH
    - git add deployments/
    - |
      if git diff --staged --quiet; then
        echo "No changes in deployment files to commit."
      else
        git commit -m "ci: Auto-generate deployment manifests [skip ci]"
        git push origin HEAD:$CI_COMMIT_BRANCH
        echo "Committed and pushed generated deployment files."
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH'

promote-to-test:
  stage: test
  image: alpine:latest

  needs:
    - commit-generated-files
  when: manual
  before_script:
    - apk add --no-cache git
    - git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - echo "Promoting branch '$CI_COMMIT_BRANCH' to 'test' branch."
    - git fetch origin
    - git push -f origin HEAD:test
  rules:
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "test"' # Keep this rule to only allow promotion from feature branches
    
trigger-production-deployment:
  stage: release
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_VERSION: $CI_COMMIT_TAG # Assumes you tag releases on main
    SERVICE_REPO_URL: $CI_PROJECT_URL
  rules:
    - if: $CI_COMMIT_TAG # Trigger deployment only when a tag is created
