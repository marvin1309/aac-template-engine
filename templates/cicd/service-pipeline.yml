# This is a reusable GitLab CI/CD pipeline for service repositories.
# It automates a full GitOps lifecycle: Generate -> Validate -> Commit -> Deploy -> Promote.

default:
  tags:
    - docker

stages:
  - generate
  - validate
  - dev-commit
  - dev-deploy
  - test-promote
  - test-deploy
  - prod-promote
  - prod-deploy

# ==========================================================================
# STAGE 1: GENERATE (runs on dev branch)
# Generate all deployment files from the service.yml SSoT.
# ==========================================================================
.generate-base:
  stage: generate
  image: python:3.9-slim
  before_script:
    - apt-get update && apt-get install -y --no-install-recommends git
    - pip install PyYAML Jinja2
    - git clone "https://gitlab-ci-token:${CI_GITLAB_TOKEN_GLOBAL_FESER}@${CI_SERVER_HOST}/aac-application-definitions/aac-template-engine.git"
  artifacts:
    paths: [deployments/]
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /ci:/'

generate-docker-compose:
  extends: .generate-base
  script:
    - SSOT_JSON=$(python -c 'import sys, yaml, json; print(json.dumps(yaml.safe_load(sys.stdin)))' < service.yml)
    - python aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --deployment-type "docker_compose"

generate-custom-files:
  extends: .generate-base
  script:
    - SSOT_JSON=$(python -c 'import sys, yaml, json; print(json.dumps(yaml.safe_load(sys.stdin)))' < service.yml)
    - python aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-files
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /ci:/'
      exists: [custom_templates/files/**/*]

# ==========================================================================
# STAGE 2: VALIDATE (runs on dev branch)
# Check the syntax of the generated files.
# ==========================================================================

validate-docker-compose:
  stage: validate
  image: docker:latest
  services: [docker:dind]
  needs: [generate-docker-compose]
  script:
    - apk add --no-cache docker-compose
    - docker-compose -f deployments/docker_compose/docker-compose.yml config
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /ci:/'

# ==========================================================================
# STAGE 3: DEV COMMIT (runs on dev branch)
# Commits generated files back to the dev branch.
# ==========================================================================
.git-commit-base:
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci-bot@${CI_SERVER_HOST}"
    - git config --global user.name "GitLab CI Bot"
    - git config --global credential.helper 'store'
    - echo "https://gitlab-ci-token:${CI_GITLAB_TOKEN_GLOBAL_FESER}@${CI_SERVER_HOST}" > ~/.git-credentials
    - git remote set-url origin "https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"

dev-commit:
  stage: dev-commit
  image: alpine:latest
  extends: .git-commit-base
  needs: [validate-docker-compose, generate-custom-files]
  script:
    - git add deployments/
    - 'git diff --staged --quiet || (git commit -m "ci: Auto-generate deployment manifests" && git push origin HEAD:$CI_COMMIT_BRANCH)'
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /ci:/'

# ==========================================================================
# STAGE 4: DEV DEPLOY (runs on dev branch)
# Triggers the Ansible pipeline to deploy the dev version.
# ==========================================================================
dev-deploy:
  stage: dev-deploy
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_BRANCH: 'dev' # Hardcode the target environment
  needs: [dev-commit]
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /ci:/'

# ==========================================================================
# STAGE 5: TEST PROMOTE (runs on dev branch)
# Promotes dev to test after a successful dev deployment.
# ==========================================================================
test-promote:
  stage: test-promote
  image: alpine:latest
  extends: .git-commit-base
  needs: [dev-deploy]
  script:
    - git fetch origin dev
    - git checkout -B test origin/dev
    - git push -f origin test
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /ci:/'

# ==========================================================================
# STAGE 6: TEST DEPLOY (runs on test branch)
# Triggers a manual deployment to the test environment.
# ==========================================================================
test-deploy:
  stage: test-deploy
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_BRANCH: 'test' # Hardcode the target environment
  rules:
    - if: '$CI_COMMIT_BRANCH == "test"'
      when: manual # Requires human validation before running
      allow_failure: false

# ==========================================================================
# STAGE 7: PROD PROMOTE (runs on test branch)
# Promotes test to main after a successful manual test deployment.
# ==========================================================================
prod-promote:
  stage: prod-promote
  image: alpine:latest
  extends: .git-commit-base
  needs: [test-deploy]
  script:
    - git fetch origin test
    - git checkout -B main origin/test
    - git push -f origin main
  rules:
    - if: '$CI_COMMIT_BRANCH == "test"'

# ==========================================================================
# STAGE 8: PROD DEPLOY (runs on main branch)
# Triggers a manual deployment to the production environment.
# ==========================================================================
prod-deploy:
  stage: prod-deploy
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_BRANCH: 'main' # Hardcode the target environment
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual # Requires human validation before running
      allow_failure: false
    
publish_to_docs:
  stage: prod-deploy
  image: alpine:latest
  variables:
    # URL zum zentralen Hugo-Dokumentations-Repository
    DOCS_REPO_URL: "https://gitlab.int.fam-feser.de/documentation/aac-iac-documentation.git"
  before_script:
    - apk add --no-cache git
    # Git für den Commit-Prozess konfigurieren
    - git config --global user.email "ci-bot@${CI_SERVER_HOST}"
    - git config --global user.name "GitLab CI Bot"
  script:
    # 1. Prüfen, ob eine `documentation.md` im Service-Repo existiert
    - |
      if [ ! -f "documentation.md" ]; then
        echo "Keine 'documentation.md' in diesem Repository gefunden. Überspringe Dokumentations-Update."
        exit 0
      fi
    
    # 2. Das zentrale Dokumentations-Repository klonen
    #    DOCS_REPO_TOKEN muss als geschützte CI/CD-Variable im Projekt/Gruppe konfiguriert sein
    - echo "Klone das Dokumentations-Repository..."
    - git clone "https://gitlab-ci-token:${DOCS_REPO_TOKEN}@$(echo "$DOCS_REPO_URL" | sed 's|https://||')" docs_repo
    - cd docs_repo

    # 3. Pfad und Dateinamen für die neue Doku-Datei vorbereiten
    - DOC_DIR="site/content/aac-services/${CI_PROJECT_NAME}"
    - DOC_FILE="${DOC_DIR}/${CI_PROJECT_NAME}-documentation.md"
    - mkdir -p "${DOC_DIR}"

    # 4. Hugo Front Matter (Header) und den Inhalt der Doku zusammenfügen
    - echo "Erstelle die Dokumentationsdatei mit Hugo-Header..."
    - |
      {
        echo "---";
        echo "title: \"Dokumentation: ${CI_PROJECT_NAME}\"";
        echo "date: $(date -u +'%Y-%m-%dT%H:%M:%SZ')";
        echo "lastmod: $(date -u +'%Y-%m-%dT%H:%M:%SZ')";
        echo "draft: false";
        echo "tags: [\"service-documentation\", \"${CI_PROJECT_NAME}\"]";
        echo "description: \"Automatisch generierte Service-Dokumentation für ${CI_PROJECT_NAME}.\"";
        echo "---";
        echo "";
        cat ../documentation.md;
        echo "";
        echo -e "---\n*Written by AI*";
      } > "${DOC_FILE}"

    # 5. Änderungen committen und zurück ins Doku-Repository pushen
    - git add "${DOC_FILE}"
    - 'git commit -m "docs: Aktualisiere Service-Dokumentation für ${CI_PROJECT_NAME}" || echo "Keine Änderungen an der Dokumentation."'
    - git push origin main
