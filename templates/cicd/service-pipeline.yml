# This is a reusable GitLab CI/CD pipeline for service repositories.
# It automates a full GitOps lifecycle for each environment:
# Generate -> Validate -> Commit -> Deploy.

default:
  tags:
    - docker

stages:
  - dev-generate
  - dev-validate
  - dev-commit
  - dev-deploy
  - test-generate
  - test-validate
  - test-commit
  - test-deploy
  - prod-generate
  - prod-validate
  - prod-commit
  - prod-deploy
  - documentation


# ==========================================================================
# REUSABLE TEMPLATES (.generate-base, .validate-base, .commit-artifacts)
# ==========================================================================

.generate-base:
  image: python:3.9-slim
  before_script:
    - apt-get update && apt-get install -y --no-install-recommends git
    - pip install PyYAML Jinja2
    - git clone "https://gitlab-ci-token:${CI_GITLAB_TOKEN_GLOBAL_FESER}@${CI_SERVER_HOST}/aac-application-definitions/aac-template-engine.git"
  artifacts:
    paths: [deployments/]
    expire_in: 1 hour
  rules:
    # This rule is a placeholder and should be overridden in the concrete jobs
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'


.validate-base:
  image: docker:latest
  services: [docker:dind]
  script:
    - apk add --no-cache docker-compose
    - docker-compose -f deployments/docker_compose/docker-compose.yml config
  artifacts:
    paths: [deployments/]
    expire_in: 1 hour
  rules:
    - if: '$CI_COMMIT_BRANCH && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

.commit-artifacts:
  image: alpine:latest
  before_script:
    # 1. Notwendige Pakete installieren (git für Repo-Operationen, rsync für das saubere Ersetzen)
    - apk add --no-cache git rsync

    # 2. DNS-Fix für deine interne GitLab-Instanz (unverändert)
    - echo "Adding DNS fix for internal GitLab instance..."
    - echo "$INTERNAL_GIT_IP gitlab.int.fam-feser.de" >> /etc/hosts # Annahme, dass die Variable so heißt

    # 3. Git-Benutzer konfigurieren
    - git config --global user.email "ci-bot@${CI_SERVER_HOST}"
    - git config --global user.name "GitLab CI Bot" # Name aus deinem alten Skript übernommen

    # 4. Authentifizierung via .netrc (sicherere Methode aus deinem alten Skript)
    #    Stellt sicher, dass du eine Projekt- oder Gruppen-Variable namens GIT_PUSH_TOKEN erstellt hast.
    - echo "machine ${CI_SERVER_HOST} login gitlab-ci-token password ${GIT_PUSH_TOKEN}" > ~/.netrc
    - git remote set-url origin "https://${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"

  script:
    - |
      # 1. Sicherstellen, dass die Artefakte (der 'deployments' Ordner) existieren.
      if [ ! -d "deployments" ]; then
        echo "Kein 'deployments'-Verzeichnis in den Artefakten gefunden. Es gibt nichts zu tun."
        exit 0
      fi

      # 2. Bereinige das Arbeitsverzeichnis von den entpackten Artefakten, um Checkout-Konflikte zu vermeiden.
      # Wir verschieben sie temporär, anstatt sie zu löschen.
      echo "Moving downloaded artifacts out of the way to allow clean checkout..."
      mv deployments /tmp/new_deployments

      # 3. Den Ziel-Branch explizit auschecken und aktualisieren.
      echo "Checkout des Ziel-Branches '${CI_COMMIT_BRANCH}'..."
      git checkout "${CI_COMMIT_BRANCH}"
      git pull origin "${CI_COMMIT_BRANCH}"

      # 4. Artefakte mit dem Repository synchronisieren (ersetzt den Inhalt komplett).
      echo "Ersetze das 'deployments'-Verzeichnis im Repository mit den neuen Artefakten..."
      rsync -a --delete /tmp/new_deployments/ ./deployments/

      # 5. Änderungen (neue, geänderte, gelöschte Dateien) zum Commit hinzufügen.
      git add deployments/

      # 6. Prüfen, ob es Änderungen gibt, und diese committen & pushen.
      if ! git diff --staged --quiet; then
        echo "Änderungen erkannt. Erstelle Commit und pushe zu '${CI_COMMIT_BRANCH}'..."
        # Commit-Nachricht aus deinem alten Skript übernommen
        git commit -m "ci: Auto-generate deployment manifests [skip ci]"
        # Robuste Push-Methode aus deinem alten Skript übernommen
        git push origin HEAD:$CI_COMMIT_BRANCH
        echo "Artefakte erfolgreich committet und gepusht."
      else
        echo "Keine Änderungen in den Artefakten. Nichts zu committen."
      fi

  rules:
    # Regel aus deinem alten Skript: Job läuft nur auf dem 'dev'-Branch 
    # und wird nicht durch seine eigenen Commits ausgelöst.
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

# ==========================================================================
# DEV WORKFLOW (runs on 'dev' branch)
# ==========================================================================
dev-generate-docker-compose:
  extends: .generate-base
  stage: dev-generate
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --deployment-type "docker_compose" --stage "dev"
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

dev-generate-custom-files:
  extends: .generate-base
  stage: dev-generate
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-files --stage "dev"
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'
      exists: [custom_templates/files/**/*]

dev-validate-docker-compose:
  extends: .validate-base
  stage: dev-validate
  needs: [dev-generate-docker-compose]
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

dev-commit:
  extends: .commit-artifacts
  stage: dev-commit
  needs:
    # Stellt sicher, dass die Validierung durchlaufen ist
    - dev-validate-docker-compose 
    # Holt sich das KOMPLETTE Artefakt (docker-compose, custom-files & docu)
    - dev-generate-documentation    
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

dev-deploy:
  stage: dev-deploy
  needs: [dev-commit]
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_BRANCH: 'dev'
    DEPLOYMENT_TYPE: 'single_service_trigger'
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

dev-generate-documentation:
  extends: .generate-base
  stage: dev-generate # Moved to generate stage
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-documentation --stage "dev"
  artifacts:
    paths:
      - deployments/ # This now includes deployments/documentation
  needs:
    - dev-generate-docker-compose
    - job: dev-generate-custom-files
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'


# ==========================================================================
# TEST WORKFLOW (runs on 'test' branch)
# ==========================================================================
test-generate-docker-compose:
  extends: .generate-base
  stage: test-generate
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --deployment-type "docker_compose" --stage "test"
  rules:
    - if: '$CI_COMMIT_BRANCH == "test" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

test-generate-custom-files:
  extends: .generate-base
  stage: test-generate
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-files --stage "test"
  rules:
    - if: '$CI_COMMIT_BRANCH == "test" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'
      exists: [custom_templates/files/**/*]

test-validate-docker-compose:
  extends: .validate-base
  stage: test-validate
  needs: [test-generate-docker-compose]
  rules:
    - if: '$CI_COMMIT_BRANCH == "test" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

test-commit:
  extends: .commit-artifacts
  stage: test-commit
  needs:
    # Stellt sicher, dass die Validierung durchlaufen ist
    - test-validate-docker-compose
    # Holt sich das KOMPLETTE Artefakt (docker-compose, custom-files & docu)
    - test-generate-documentation
  rules:
    - if: '$CI_COMMIT_BRANCH == "test" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

test-deploy:
  stage: test-deploy
  needs: [test-commit]
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_BRANCH: 'test'
    DEPLOYMENT_TYPE: 'single_service_trigger'
  rules:
    - if: '$CI_COMMIT_BRANCH == "test" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

test-generate-documentation:
  extends: .generate-base
  stage: test-generate # Moved to generate stage
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-documentation --stage "test"
  artifacts:
    paths:
      - deployments/ # This now includes deployments/documentation
  needs:
    - test-generate-docker-compose
    - job: test-generate-custom-files
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "test" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

# ==========================================================================
# PROD WORKFLOW (runs on 'main' branch)
# ==========================================================================
prod-generate-docker-compose:
  extends: .generate-base
  stage: prod-generate
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --deployment-type "docker_compose" --stage "prod"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

prod-generate-custom-files:
  extends: .generate-base
  stage: prod-generate
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-files --stage "prod"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'
      exists: [custom_templates/files/**/*]

prod-validate-docker-compose:
  extends: .validate-base
  stage: prod-validate
  needs: [prod-generate-docker-compose]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

prod-commit:
  extends: .commit-artifacts
  stage: prod-commit
  needs:
    # Stellt sicher, dass die Validierung durchlaufen ist
    - prod-validate-docker-compose
    # Holt sich das KOMPLETTE Artefakt (docker-compose, custom-files & docu)
    - prod-generate-documentation
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'

# ==========================================================================
# DOCUMENTATION WORKFLOW
# ==========================================================================
publish_to_docs:
  stage: documentation
  image: alpine:latest
  needs: [prod-commit]
  variables:
    DOCS_REPO_URL: "https://gitlab.int.fam-feser.de/documentation/aac-iac-documentation.git"
  script:
    - |
      # 1. Vorbereitung und Überprüfung
      DOC_SOURCE_DIR="deployments/documentation"
      
      # Überprüfen, ob das Quellverzeichnis existiert und .md-Dateien enthält
      if ! ls -A "${DOC_SOURCE_DIR}"/*.md >/dev/null 2>&1; then
        echo "Keine .md-Dateien in '${DOC_SOURCE_DIR}' gefunden. Überspringe Dokumentations-Update."
        exit 0
      fi
      
      echo "Richte Git ein und klone das Dokumentations-Repository..."
      apk add --no-cache git
      git config --global user.email "ci-bot@${CI_SERVER_HOST}"
      git config --global user.name "GitLab CI Documentation Bot"
      # Klone das Ziel-Repository
      git clone "https://gitlab-ci-token:${DOCS_REPO_TOKEN}@$(echo "$DOCS_REPO_URL" | sed 's|https://||')" docs_repo
      cd docs_repo

      # 2. Verarbeite jede Markdown-Datei
      TARGET_DOC_DIR="site/content/aac-services/${CI_PROJECT_NAME}"
      mkdir -p "${TARGET_DOC_DIR}"

      echo "Verarbeite alle .md-Dateien aus dem Quellverzeichnis..."
      # Finde alle .md-Dateien im Quellverzeichnis (außerhalb des geklonten Repos)
      for SOURCE_FILE in ../${DOC_SOURCE_DIR}/*.md; do
        # Extrahiere den reinen Dateinamen (z.B. "documentation.md")
        SOURCE_BASENAME=$(basename "${SOURCE_FILE}")
        # Erstelle einen Titel aus dem Dateinamen (z.B. "documentation")
        FILE_TITLE=$(echo "${SOURCE_BASENAME}" | sed 's/\.md$//')

        TARGET_FILE="${TARGET_DOC_DIR}/${SOURCE_BASENAME}"
        echo "Erstelle '${TARGET_FILE}' mit Hugo-Header..."

        # Erstelle die Zieldatei mit dynamischem Header
        {
          echo "---";
          echo "title: \"${CI_PROJECT_NAME}: $(echo "$FILE_TITLE" | sed 's/.*/\u&/')\""; # Ersten Buchstaben groß
          echo "date: $(date -u +'%Y-%m-%dT%H:%M:%SZ')";
          echo "lastmod: $(date -u +'%Y-%m-%dT%H:%M:%SZ')";
          echo "draft: false";
          echo "description: \"Automatisch generierte Dokumentation für ${CI_PROJECT_NAME} - ${FILE_TITLE}.\"";
          echo "---";
          echo "";
          cat "${SOURCE_FILE}";
        } > "${TARGET_FILE}"

        # Füge die erstellte Datei zum Staging-Bereich von Git hinzu
        git add "${TARGET_FILE}"
      done

      # 3. Committe und pushe alle Änderungen gesammelt
      echo "Überprüfe auf Änderungen..."
      if ! git diff --staged --quiet; then
        echo "Änderungen gefunden. Erstelle Commit und pushe..."
        git commit -m "docs: Aktualisiere Service-Dokumentation für ${CI_PROJECT_NAME}"
        git push origin main
        echo "Dokumentation erfolgreich aktualisiert."
      else
        echo "Keine Änderungen an der Dokumentation festgestellt."
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'
      when: on_success




prod-deploy:
  stage: prod-deploy
  needs: [prod-commit]
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_BRANCH: 'main'
    DEPLOYMENT_TYPE: 'single_service_trigger'
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'
      when: manual
      allow_failure: false

prod-generate-documentation:
  extends: .generate-base
  stage: prod-generate # Moved to generate stage
  script:
    - SSOT_JSON=$(python3 -c 'import yaml, json; print(json.dumps(yaml.safe_load(open("service.yml"))))')
    - python3 aac-template-engine/scripts/generate_manifest.py --ssot-json "$SSOT_JSON" --template-path aac-template-engine --process-documentation --stage "prod"
  artifacts:
    paths:
      - deployments/ # This now includes deployments/documentation
  needs:
    - prod-generate-docker-compose
    - job: prod-generate-custom-files
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE !~ /\[skip ci\]/'
