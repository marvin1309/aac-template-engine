# This is a reusable GitLab CI/CD pipeline for service repositories.
# It automates the generation, validation, and commit of deployment configurations.
#
# How to use:
# In your service's .gitlab-ci.yml, include this file:
#
# include:
#   - project: 'aac-application-definitions/aac-template-engine'
#     ref: main
#     file: '/templates/cicd/service-pipeline.yml'
#
# Required CI/CD variables in the service project's settings:
# - GIT_PUSH_TOKEN: A GitLab Project Access Token with the 'write_repository' scope.
#                   This is required for the pipeline to commit generated files back to the repo.

workflow:
  rules:
    - if: $CI_COMMIT_BRANCH

stages:
  - generate
  - validate
  - commit
  - test
  - release

.generate-job:
  stage: generate
  image: python:3.9-slim
  before_script:
    - pip install pyyaml jinja2
    # Clone the template engine to get the generation script.
    # This assumes the template engine repo is private and requires a token.
    - git clone "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/aac-application-definitions/aac-template-engine.git"
  script:
    - echo "Generating '$DEPLOYMENT_TYPE' deployment..."
    - python aac-template-engine/scripts/generate_manifest.py --ssot-file service.yml --deployment-type $DEPLOYMENT_TYPE
  artifacts:
    paths:
      - deployments/
    expire_in: 1 hour
  tags:
    - docker  
generate-docker-compose:
  extends: .generate-job
  variables:
    DEPLOYMENT_TYPE: docker_compose
  tags:
    - docker
  rules:
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "test"'
validate-docker-compose:
  stage: validate
  image: docker:latest
  services:
    - docker:dind
  needs:
    - generate-docker-compose
  script:
    - |
      if [ -f "deployments/docker_compose/docker-compose.yml" ]; then
        echo "Validating generated docker-compose.yml syntax..."
        apk add --no-cache docker-compose
        docker-compose -f deployments/docker_compose/docker-compose.yml config
      else
        echo "No docker-compose.yml found to validate."
        exit 1
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "test"'
  tags:
    - docker
commit-generated-files:
  stage: commit
  image: alpine:latest
  needs:
    - validate-docker-compose
  tags:
    - docker
  before_script:
    - apk add --no-cache git
    - git config --global user.email "ci-bot@${CI_SERVER_HOST}"
    - git config --global user.name "GitLab CI Bot"
    - git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - git fetch
    - git checkout $CI_COMMIT_BRANCH
    - git add deployments/
    - |
      if git diff --staged --quiet; then
        echo "No changes in deployment files to commit."
      else
        git commit -m "ci: Auto-generate deployment manifests [skip ci]"
        git push origin HEAD:$CI_COMMIT_BRANCH
        echo "Committed and pushed generated deployment files."
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "test"'
promote-to-test:
  stage: test
  image: alpine:latest
  tags:
    - docker

  needs:
    - commit-generated-files
  when: manual
  before_script:
    - apk add --no-cache git
    - git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
  script:
    - echo "Promoting branch '$CI_COMMIT_BRANCH' to 'test' branch."
    - git fetch origin
    - git push -f origin HEAD:test
  rules:
    - if: '$CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "test"'

trigger-production-deployment:
  stage: release
  trigger:
    project: 'iac-environment/iac-ansible-automation'
    branch: main
    strategy: depend
  variables:
    SERVICE_NAME: $CI_PROJECT_NAME
    SERVICE_VERSION: $CI_COMMIT_TAG # Assumes you tag releases on main
    SERVICE_REPO_URL: $CI_PROJECT_URL
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

